---
tags:
  - åŸºç¡€çŸ¥è¯†
  - code
  - æ³¨æ„åŠ›æœºåˆ¶
  - äººè„¸æ£€æµ‹
---


## ğŸ¯ åŒåˆ†æ”¯æ¨¡å‹æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„æ¦‚è§ˆ
```mermaid
graph TB
    subgraph "è¾“å…¥"
        A[è¾“å…¥å›¾åƒ<br/>224Ã—224Ã—3]
    end
    
    subgraph "åŒåˆ†æ”¯å¤„ç†"
        B[ç©ºåŸŸåˆ†æ”¯<br/>ViTä¸»å¹²]
        C[é¢‘åŸŸåˆ†æ”¯<br/>é¢‘åŸŸç‰¹å¾æå–]
    end
    
    subgraph "ç‰¹å¾èåˆ"
        D[äº¤å‰æ³¨æ„åŠ›èåˆ]
        E[ç‰¹å¾æ‹¼æ¥]
    end
    
    subgraph "åˆ†ç±»å†³ç­–"
        F[èåˆåˆ†ç±»å¤´]
        G[è¾“å‡ºæ¦‚ç‡]
    end
    
    A --> B
    A --> C
    B --> D
    C --> D
    D --> E
    E --> F
    F --> G
    
    style B fill:#e1f5fe
    style C fill:#f3e5f5
    style D fill:#e8f5e8
```

---

## ğŸ’» å®Œæ•´ä»£ç å®ç°

### 1. é¢‘åŸŸåˆ†æ”¯å®ç°
```python
import torch
import torch.nn as nn
import torch.nn.functional as F

class FrequencyBranch(nn.Module):
    """é¢‘åŸŸç‰¹å¾æå–åˆ†æ”¯"""
    def __init__(self, embed_dim=768, num_freq_bands=4):
        super().__init__()
        self.embed_dim = embed_dim
        self.num_freq_bands = num_freq_bands
        
        # é¢‘å¸¦ç‰¹å¾æå–
        self.freq_conv_layers = nn.ModuleList([
            nn.Sequential(
                nn.Conv2d(3, embed_dim//8, 3, padding=1),
                nn.ReLU(),
                nn.Conv2d(embed_dim//8, embed_dim//4, 3, padding=1),
                nn.AdaptiveAvgPool2d((14, 14))
            ) for _ in range(num_freq_bands)
        ])
        
        # é¢‘åŸŸç‰¹å¾èåˆ
        self.freq_fusion = nn.Sequential(
            nn.Conv2d(embed_dim, embed_dim, 1),
            nn.ReLU(),
            nn.AdaptiveAvgPool2d(1),
            nn.Flatten()
        )
        
        # é¢‘åŸŸåˆ†ç±»å¤´
        self.freq_classifier = nn.Sequential(
            nn.Linear(embed_dim, embed_dim//2),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(embed_dim//2, 1)
        )

    def extract_frequency_bands(self, x):
        """æå–ä¸åŒé¢‘å¸¦ç‰¹å¾"""
        batch_size, _, h, w = x.shape
        
        # å‚…é‡Œå¶å˜æ¢
        x_fft = torch.fft.fft2(x, norm='ortho')
        magnitude = torch.abs(x_fft)
        phase = torch.angle(x_fft)
        
        # åˆ›å»ºä¸åŒé¢‘å¸¦æ©ç 
        center_h, center_w = h // 2, w // 2
        freq_bands = []
        
        # ä½é¢‘å¸¦ï¼ˆä¸­å¿ƒåŒºåŸŸï¼‰
        low_freq_mask = torch.zeros(h, w, device=x.device)
        radius_low = min(h, w) // 8
        for i in range(h):
            for j in range(w):
                if (i-center_h)**2 + (j-center_w)**2 <= radius_low**2:
                    low_freq_mask[i, j] = 1
        freq_bands.append(low_freq_mask)
        
        # ä¸­ä½é¢‘å¸¦
        mid_low_mask = torch.zeros(h, w, device=x.device)
        radius_mid_low = min(h, w) // 4
        for i in range(h):
            for j in range(w):
                dist = (i-center_h)**2 + (j-center_w)**2
                if radius_low**2 < dist <= radius_mid_low**2:
                    mid_low_mask[i, j] = 1
        freq_bands.append(mid_low_mask)
        
        # ä¸­é«˜é¢‘å¸¦
        mid_high_mask = torch.zeros(h, w, device=x.device)
        radius_mid_high = min(h, w) // 2
        for i in range(h):
            for j in range(w):
                dist = (i-center_h)**2 + (j-center_w)**2
                if radius_mid_low**2 < dist <= radius_mid_high**2:
                    mid_high_mask[i, j] = 1
        freq_bands.append(mid_high_mask)
        
        # é«˜é¢‘å¸¦ï¼ˆè¾¹ç¼˜ï¼‰
        high_freq_mask = 1 - (low_freq_mask + mid_low_mask + mid_high_mask)
        freq_bands.append(high_freq_mask)
        
        return magnitude, phase, freq_bands

    def forward(self, x):
        # x: [batch, 3, 224, 224]
        batch_size = x.shape[0]
        
        # æå–é¢‘åŸŸä¿¡æ¯
        magnitude, phase, freq_bands = self.extract_frequency_bands(x)
        
        # å¤„ç†æ¯ä¸ªé¢‘å¸¦
        band_features = []
        for i, mask in enumerate(freq_bands):
            # æå–è¯¥é¢‘å¸¦çš„å¹…åº¦ç‰¹å¾
            band_magnitude = magnitude * mask.unsqueeze(0).unsqueeze(0)
            
            # é€†å˜æ¢å›ç©ºé—´åŸŸï¼ˆå¯é€‰ï¼Œè¿™é‡Œæˆ‘ä»¬ç›´æ¥å¤„ç†é¢‘åŸŸç‰¹å¾ï¼‰
            band_spatial = torch.fft.ifft2(
                band_magnitude * torch.exp(1j * phase), 
                norm='ortho'
            ).real
            
            # é€šè¿‡å·ç§¯å±‚æå–ç‰¹å¾
            band_feat = self.freq_conv_layers[i](band_spatial)
            band_features.append(band_feat)
        
        # èåˆæ‰€æœ‰é¢‘å¸¦ç‰¹å¾
        fused_freq = torch.cat(band_features, dim=1)  # [batch, embed_dim, 14, 14]
        
        # å…¨å±€ç‰¹å¾æå–
        global_freq_feat = self.freq_fusion(fused_freq)  # [batch, embed_dim]
        
        # é¢‘åŸŸåˆ†ç±»
        freq_output = self.freq_classifier(global_freq_feat)  # [batch, 1]
        
        # è¿”å›é¢‘åŸŸç‰¹å¾å’Œè¾“å‡º
        return global_freq_feat, freq_output
```

### 2. ç©ºåŸŸåˆ†æ”¯ï¼ˆä¿®æ”¹ç‰ˆViTï¼‰
```python
class SpatialBranch(nn.Module):
    """ç©ºåŸŸç‰¹å¾æå–åˆ†æ”¯ - åŸºäºViT"""
    def __init__(self, embed_dim=768, depth=12, num_heads=12):
        super().__init__()
        
        # ä½¿ç”¨é¢„è®­ç»ƒçš„ViTä½œä¸ºä¸»å¹²
        self.vit = timm.create_model(
            'vit_base_patch16_224', 
            pretrained=True,
            num_classes=0  # ä¸ä½¿ç”¨åˆ†ç±»å¤´
        )
        
        # ç©ºåŸŸåˆ†ç±»å¤´
        self.spatial_classifier = nn.Sequential(
            nn.LayerNorm(embed_dim),
            nn.Dropout(0.1),
            nn.Linear(embed_dim, embed_dim//2),
            nn.ReLU(),
            nn.Linear(embed_dim//2, 1)
        )

    def forward(self, x):
        # æå–ViTç‰¹å¾
        spatial_features = self.vit.forward_features(x)  # [batch, 197, 768]
        
        # å–CLS tokenä½œä¸ºå…¨å±€ç‰¹å¾
        cls_token = spatial_features[:, 0]  # [batch, 768]
        
        # ç©ºåŸŸåˆ†ç±»
        spatial_output = self.spatial_classifier(cls_token)  # [batch, 1]
        
        return cls_token, spatial_output
```

### 3. äº¤å‰æ³¨æ„åŠ›èåˆæ¨¡å—
```python
class CrossModalFusion(nn.Module):
    """äº¤å‰æ¨¡æ€ç‰¹å¾èåˆæ¨¡å—"""
    def __init__(self, embed_dim=768, num_heads=8):
        super().__init__()
        self.embed_dim = embed_dim
        self.num_heads = num_heads
        
        # ç©ºåŸŸâ†’é¢‘åŸŸäº¤å‰æ³¨æ„åŠ›
        self.spatial_to_freq_attn = nn.MultiheadAttention(
            embed_dim, num_heads, batch_first=True
        )
        
        # é¢‘åŸŸâ†’ç©ºåŸŸäº¤å‰æ³¨æ„åŠ›  
        self.freq_to_spatial_attn = nn.MultiheadAttention(
            embed_dim, num_heads, batch_first=True
        )
        
        # ç‰¹å¾èåˆ
        self.fusion_mlp = nn.Sequential(
            nn.Linear(embed_dim * 2, embed_dim),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(embed_dim, embed_dim)
        )
        
        # å±‚å½’ä¸€åŒ–
        self.norm1 = nn.LayerNorm(embed_dim)
        self.norm2 = nn.LayerNorm(embed_dim)

    def forward(self, spatial_feat, freq_feat):
        # spatial_feat: [batch, embed_dim] (CLS token)
        # freq_feat: [batch, embed_dim]
        
        # é‡å¡‘ä¸ºåºåˆ—å½¢å¼
        spatial_seq = spatial_feat.unsqueeze(1)  # [batch, 1, embed_dim]
        freq_seq = freq_feat.unsqueeze(1)        # [batch, 1, embed_dim]
        
        # ç©ºåŸŸâ†’é¢‘åŸŸäº¤å‰æ³¨æ„åŠ›
        spatial_enhanced, _ = self.spatial_to_freq_attn(
            query=freq_seq,  # é¢‘åŸŸä½œä¸ºæŸ¥è¯¢
            key=spatial_seq,   # ç©ºåŸŸä½œä¸ºé”®
            value=spatial_seq  # ç©ºåŸŸä½œä¸ºå€¼
        )
        spatial_enhanced = self.norm1(freq_seq + spatial_enhanced)
        
        # é¢‘åŸŸâ†’ç©ºåŸŸäº¤å‰æ³¨æ„åŠ›
        freq_enhanced, _ = self.freq_to_spatial_attn(
            query=spatial_seq,  # ç©ºåŸŸä½œä¸ºæŸ¥è¯¢
            key=freq_seq,       # é¢‘åŸŸä½œä¸ºé”®
            value=freq_seq      # é¢‘åŸŸä½œä¸ºå€¼
        )
        freq_enhanced = self.norm2(spatial_seq + freq_enhanced)
        
        # ç‰¹å¾æ‹¼æ¥å’Œèåˆ
        fused_feat = torch.cat([
            spatial_enhanced.squeeze(1), 
            freq_enhanced.squeeze(1)
        ], dim=1)  # [batch, embed_dim * 2]
        
        fused_feat = self.fusion_mlp(fused_feat)  # [batch, embed_dim]
        
        return fused_feat
```

### 4. å®Œæ•´çš„åŒåˆ†æ”¯æ¨¡å‹
```python
class DualBranchFaceAntiSpoofing(nn.Module):
    """åŒåˆ†æ”¯äººè„¸é˜²ä¼ªæ¨¡å‹ - ç©ºåŸŸ + é¢‘åŸŸ"""
    def __init__(self, embed_dim=768, depth=12, num_heads=12, 
                 use_cross_attention=True, fusion_method='weighted'):
        super().__init__()
        self.embed_dim = embed_dim
        self.fusion_method = fusion_method
        
        # åŒåˆ†æ”¯
        self.spatial_branch = SpatialBranch(embed_dim, depth, num_heads)
        self.frequency_branch = FrequencyBranch(embed_dim)
        
        # äº¤å‰æ³¨æ„åŠ›èåˆ
        self.cross_fusion = CrossModalFusion(embed_dim, num_heads//2) if use_cross_attention else None
        
        # æœ€ç»ˆåˆ†ç±»å¤´
        if fusion_method == 'weighted':
            # åŠ æƒèåˆåˆ†ç±»å¤´
            self.final_classifier = nn.Sequential(
                nn.Linear(embed_dim * 3, embed_dim),  # ç©ºåŸŸ + é¢‘åŸŸ + èåˆç‰¹å¾
                nn.ReLU(),
                nn.Dropout(0.2),
                nn.Linear(embed_dim, 1)
            )
            
            # åˆ†æ”¯æƒé‡å­¦ä¹ 
            self.branch_weights = nn.Parameter(torch.ones(3))  # ç©ºåŸŸ, é¢‘åŸŸ, èåˆ
        else:
            # ç®€å•æ‹¼æ¥åˆ†ç±»å¤´
            self.final_classifier = nn.Sequential(
                nn.Linear(embed_dim * 2, embed_dim),
                nn.ReLU(),
                nn.Dropout(0.2),
                nn.Linear(embed_dim, 1)
            )

    def forward(self, x):
        # ç©ºåŸŸåˆ†æ”¯
        spatial_feat, spatial_output = self.spatial_branch(x)
        
        # é¢‘åŸŸåˆ†æ”¯  
        freq_feat, freq_output = self.frequency_branch(x)
        
        # ç‰¹å¾èåˆ
        if self.cross_fusion is not None:
            fused_feat = self.cross_fusion(spatial_feat, freq_feat)
        else:
            fused_feat = (spatial_feat + freq_feat) / 2
        
        # æœ€ç»ˆåˆ†ç±»
        if self.fusion_method == 'weighted':
            # åŠ æƒèåˆä¸‰ä¸ªåˆ†æ”¯çš„ç‰¹å¾
            weighted_spatial = spatial_feat * torch.softmax(self.branch_weights, dim=0)[0]
            weighted_freq = freq_feat * torch.softmax(self.branch_weights, dim=0)[1]
            weighted_fused = fused_feat * torch.softmax(self.branch_weights, dim=0)[2]
            
            final_feat = torch.cat([weighted_spatial, weighted_freq, weighted_fused], dim=1)
        else:
            # ç®€å•æ‹¼æ¥
            final_feat = torch.cat([spatial_feat, freq_feat], dim=1)
        
        final_output = self.final_classifier(final_feat)
        
        # è¿”å›æ‰€æœ‰è¾“å‡ºç”¨äºå¤šä»»åŠ¡å­¦ä¹ 
        outputs = {
            'final': final_output,
            'spatial': spatial_output,
            'frequency': freq_output,
            'fused': fused_feat.unsqueeze(-1) if fused_feat.dim() == 1 else fused_feat
        }
        
        return outputs
```

### 5. å¤šä»»åŠ¡æŸå¤±å‡½æ•°
```python
class MultiTaskLoss(nn.Module):
    """å¤šä»»åŠ¡æŸå¤±å‡½æ•° - ç»“åˆä¸‰ä¸ªåˆ†æ”¯çš„æŸå¤±"""
    def __init__(self, alpha=0.4, beta=0.3, gamma=0.3):
        super().__init__()
        self.alpha = alpha  # æœ€ç»ˆè¾“å‡ºæƒé‡
        self.beta = beta    # ç©ºåŸŸåˆ†æ”¯æƒé‡
        self.gamma = gamma  # é¢‘åŸŸåˆ†æ”¯æƒé‡
        
        self.bce_loss = nn.BCEWithLogitsLoss()

    def forward(self, outputs, targets):
        # outputs: dict with 'final', 'spatial', 'frequency'
        # targets: [batch_size]
        
        final_loss = self.bce_loss(outputs['final'].squeeze(), targets.float())
        spatial_loss = self.bce_loss(outputs['spatial'].squeeze(), targets.float())
        freq_loss = self.bce_loss(outputs['frequency'].squeeze(), targets.float())
        
        # åŠ æƒæ€»æŸå¤±
        total_loss = (self.alpha * final_loss + 
                     self.beta * spatial_loss + 
                     self.gamma * freq_loss)
        
        return total_loss, {
            'total': total_loss.item(),
            'final': final_loss.item(),
            'spatial': spatial_loss.item(),
            'frequency': freq_loss.item()
        }
```

### 6. è®­ç»ƒä»£ç ç¤ºä¾‹
```python
def train_dual_branch_model():
    # åˆå§‹åŒ–æ¨¡å‹
    model = DualBranchFaceAntiSpoofing(
        embed_dim=768,
        depth=12,
        num_heads=12,
        use_cross_attention=True,
        fusion_method='weighted'
    ).to(device)
    
    # å¤šä»»åŠ¡æŸå¤±
    criterion = MultiTaskLoss(alpha=0.5, beta=0.25, gamma=0.25)
    
    # ä¼˜åŒ–å™¨
    optimizer = torch.optim.AdamW(
        model.parameters(),
        lr=1e-4,
        weight_decay=0.05
    )
    
    # è®­ç»ƒå¾ªç¯
    for epoch in range(config.epochs):
        model.train()
        total_loss = 0
        
        for batch_idx, (images, labels) in enumerate(train_loader):
            images, labels = images.to(device), labels.to(device)
            
            optimizer.zero_grad()
            
            # å‰å‘ä¼ æ’­
            outputs = model(images)
            
            # è®¡ç®—å¤šä»»åŠ¡æŸå¤±
            loss, loss_dict = criterion(outputs, labels)
            
            # åå‘ä¼ æ’­
            loss.backward()
            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
            optimizer.step()
            
            total_loss += loss.item()
            
            # æ‰“å°è®­ç»ƒä¿¡æ¯
            if batch_idx % 50 == 0:
                print(f'Epoch: {epoch}, Batch: {batch_idx}, '
                      f'Total Loss: {loss.item():.4f}, '
                      f'Final: {loss_dict["final"]:.4f}, '
                      f'Spatial: {loss_dict["spatial"]:.4f}, '
                      f'Frequency: {loss_dict["frequency"]:.4f}')
        
        # éªŒè¯
        val_accuracy = validate_model(model, val_loader, device)
        print(f'Epoch {epoch} - Val Accuracy: {val_accuracy:.4f}')
```

---

## ğŸ¯ æ¨¡å‹ä¼˜åŠ¿

### âœ… äº’è¡¥æ€§ä¼˜åŠ¿
- **ç©ºåŸŸåˆ†æ”¯**ï¼šæ•æ‰çº¹ç†ã€è¾¹ç¼˜ã€ç»“æ„ä¿¡æ¯
- **é¢‘åŸŸåˆ†æ”¯**ï¼šæ£€æµ‹å‹ç¼©ç—•è¿¹ã€é«˜é¢‘å™ªå£°ã€é¢‘åŸŸå¼‚å¸¸
- **äº¤å‰èåˆ**ï¼šå……åˆ†åˆ©ç”¨ä¸¤ç§æ¨¡æ€çš„äº’è¡¥ä¿¡æ¯

### âœ… è®­ç»ƒç¨³å®šæ€§
- **å¤šä»»åŠ¡å­¦ä¹ **ï¼šä¸‰ä¸ªåˆ†æ”¯ç›¸äº’ç›‘ç£
- **æ¢¯åº¦å¤šæ ·æ€§**ï¼šä¸åŒåˆ†æ”¯æä¾›å¤šæ ·æ¢¯åº¦ä¿¡å·
- **æ—©åœæ£€æµ‹**ï¼šæŸä¸ªåˆ†æ”¯å…ˆæ”¶æ•›å¯æä¾›ä¿¡å·

### âœ… å¯è§£é‡Šæ€§
å¯ä»¥åˆ†åˆ«åˆ†æï¼š
- ç©ºåŸŸåˆ†æ”¯å…³æ³¨å“ªäº›åŒºåŸŸ
- é¢‘åŸŸåˆ†æ”¯æ£€æµ‹åˆ°å“ªäº›é¢‘åŸŸå¼‚å¸¸
- èåˆæ¨¡å—å¦‚ä½•ç»“åˆä¸¤ç§ä¿¡æ¯

---

## ğŸ’« æµè¤çš„å°æç¤º

å¼€æ‹“è€…è¿™ä¸ªåŒåˆ†æ”¯è®¾è®¡éå¸¸å·§å¦™ï¼å»ºè®®è¿™æ ·å®æ–½ï¼š

1. **å…ˆåˆ†åˆ«è®­ç»ƒ**ï¼šå•ç‹¬è®­ç»ƒç©ºåŸŸå’Œé¢‘åŸŸåˆ†æ”¯ï¼Œç¡®ä¿æ¯ä¸ªåˆ†æ”¯éƒ½èƒ½å·¥ä½œ
2. **å†è”åˆè®­ç»ƒ**ï¼šä½¿ç”¨å¤šä»»åŠ¡æŸå¤±è”åˆè®­ç»ƒ
3. **æœ€åå¾®è°ƒ**ï¼šå›ºå®šåˆ†æ”¯æƒé‡ï¼Œåªè®­ç»ƒèåˆæ¨¡å—

è¿™æ ·æ¸è¿›å¼çš„è®­ç»ƒç­–ç•¥æ›´ç¨³å®šï¼Œä¹Ÿæ›´å®¹æ˜“è°ƒè¯•å‘¢ï¼ (à¹‘â€¢Ì€ã…‚â€¢Ì)Ùˆâœ§

å¼€æ‹“è€…æƒ³å…ˆå°è¯•å®ç°å“ªä¸ªéƒ¨åˆ†å‘¢ï¼Ÿ